{"ast":null,"code":"import _toConsumableArray from \"/home/juliette/Documents/memorylaporte/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/juliette/Documents/memorylaporte/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/juliette/Documents/memorylaporte/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/juliette/Documents/memorylaporte/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/juliette/Documents/memorylaporte/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/juliette/Documents/memorylaporte/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/home/juliette/Documents/memorylaporte/src/App.js\";\nimport React, { Component } from 'react';\nimport shuffle from 'lodash.shuffle';\nimport './App.css';\nimport HighScoreInput from \"./HighScoreInput\";\nimport Card from './Card';\nimport GuessCount from './GuessCount';\nimport HallOfFame from './HallOfFame';\nimport PairedCards from './PairedCards';\nvar SIDE = 6;\nvar SYMBOLS = '😀🎉💖🎩🐶🐱🦄🐬🌍🌛🌞💫🍎🍌🍓🍐🍟🍿';\nvar VISUAL_PAUSE_MSECS = 750; // Le but de cette application est d'arriver à trouver 15 paires qui se ressemblent\n// Les 15 paires doivent être trouvées par le joueur en cliquant sur les cartes , \n// Une fois qu'il a cliqué 2 fois, si les 2 cartes sont les mêmes, elles restent affichées\n// Si elles sont différentes, elles disparaissent\n// lorsque les 15 paires sont trouvées un composant HallOfFame apparaît\n\nvar App =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(App, _Component);\n\n  function App() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, App);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(App)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.state = {\n      cards: _this.generateCards(),\n      currentPair: [],\n      guesses: 0,\n      myEntries: null,\n      matchedCardIndices: [],\n      matchedCardSymbols: [] // Fait un tableau d'icones à partir de symbols\n      // est appelé dès l'init      \n\n    };\n\n    _this.handleCardClick = function (index) {\n      console.log(\"HANDLECARDCLICK ::: DEBUT\");\n      console.log(\"HANDLECARDCLICK ::: est appelée à chaque click\");\n      console.log(\"HANDLECARDCLICK ::: on vient de cliquer sur une carte qui se trouve à l'index ; \", index, \" du tableau this.cards \", _this.state.cards);\n      var currentPair = _this.state.currentPair;\n\n      if (currentPair.length === 0) {\n        return _this.setState({\n          currentPair: [index]\n        });\n      }\n\n      if (currentPair.length === 2) {\n        return;\n      }\n\n      return _this.handleNewPairClosedBy(index); // pour l'instant ce code n'est pas appelle\n      // ce code est appellé lors du premier click\n      // si toute les cartes sont avec un ? c'est qu'aucune pair n'a commencé à êtrer créée\n      // donc le tableau currentpair qui gère les paires de cartes, est vide\n      // puisque le tableau est vide on met à jour le currentPair ds le state avec\n      // l'index de la carte qui vient d'etre cliquée\n      // et donc maintenant le currentPair du State n'est plus vide et n'est plus égal à 0, donc on ne repassera \n      // plus ici \n\n      console.log(\" HANDLECARDCLICK ::: l'index sur lequel on a cliqué est placé dans currentPair\");\n      console.log(\" HANDLECARDCLICK ::: on fait un set state pour currentPair\"); // ce code est appellé au deuxième clique\n\n      console.log(\"HANDLECARDCLICK ::: 2EME CLICK : on appelle handleNewPairClosedBy\");\n      console.log(\"HANDLECARDCLICK ::: FIN\");\n    };\n\n    _this.displayHallOfFame = function (entries) {\n      _this.setState({\n        myEntries: entries\n      }); // On peut aussi l'écrire comme ça : \n      // this.setState({ hallOfFame })\n      // ené écrivant (hallOfFame) à la place de (entries) ds les params ^\n\n    };\n\n    return _this;\n  }\n\n  _createClass(App, [{\n    key: \"generateCards\",\n    value: function generateCards() {\n      console.log(\"GENERATECARDS ::: DEBUT\");\n      console.log(\"GENERATECARDS ::: INIT de l'aplication\");\n      console.log(\"GENERATECARDS ::: on construit le tableau de cards\");\n      var result = [];\n      var size = SIDE * SIDE;\n      var candidates = shuffle(SYMBOLS);\n\n      while (result.length < size) {\n        var card = candidates.pop();\n        result.push(card, card);\n      }\n\n      return shuffle(result);\n    } // défini si ma carte est visible ou pas,\n    // du coup est appelé à chaque fois qu'on clique\n    // et à chaque fois qu'on clique il y a un render et elle est appelée pour chaque instance de <Card>\n    // voilà comment est appelé ce code :\n    // {this.getFeedbackForCard(index)}\n    // la fonction est appelé avec les parenthèses et un paramètre\n    // donc ici le this est connu\n\n  }, {\n    key: \"getFeedbackForCard\",\n    value: function getFeedbackForCard(index) {\n      console.log(\"GETFEEDBACKFORCARDS ::: DEBUT\");\n      console.log(\"GETFEEDBACKFORCARDS ::: détermine comment il faut afficher la carte\");\n      console.log(\"GETFEEDBACKFORCARDS ::: voici index : \", index);\n      var _this$state = this.state,\n          currentPair = _this$state.currentPair,\n          matchedCardIndices = _this$state.matchedCardIndices;\n      console.log(\"GETFEEDBACKFORCARDS::: voici la valeur de currentPair : \", currentPair); // indexMatched est un booleen, il regarde si il y a \"index\" dans le tableau matchedCardIndices,\n      // le tableau matchedCardIndices contient les paires qui ont déjà été validées\n\n      var indexMatched = matchedCardIndices.includes(index);\n      console.log(\"GETFEEDBACKFORCARDS ::: voici matchecardindices : \".concat(matchedCardIndices));\n      console.log(\"GETFEEDBACKFORCARDS ::: voici indexMatched : \".concat(indexMatched)); // ce code est appelé lors du 1er click\n\n      if (currentPair.length < 2) {\n        // ici , c le premier click, on regarde si indexMatched est à true, si oui ça veut dire que l'index \n        // sur lequel on a clické\n        // fait deja partie d'une paire donc ici on fait un return ce qui fait que l'instruction\n        // après le || n'est pas effectuée et surtout qu'on return, ce qui arrete la méthode,\n        //return indexMatched || currentPair[0] === index ? \"visible\" : \"hidden\"\n\n        /* Cette ligne ^ peut s'écrire comme ça :  */\n        if (indexMatched) {\n          return;\n        } else {\n          // d'abord handleclick est appelé, il place dans currentPair l'index qui a été clické      \n          // donc ici est retourné visible pour cet index et sinon hidden\n          return index === currentPair[0] ? 'visible' : 'hidden';\n        }\n      }\n\n      if (currentPair.includes(index)) {\n        return indexMatched ? 'justMatched' : 'justMismatched';\n      }\n\n      return indexMatched ? 'visible' : 'hidden'; // comprendre cette ligne de code : \n      // soit on retourne indexMatched soit on retourne la réponse de la condition ternaire\n      // Si indexMatched === true alors on retourne true \n      // Si indexMatched === false alors on execute la condition ternaire\n      // la condition ternaire : la condition ternaire dit si index est égal au 1er élément du tableau \n      // currentPair alors on retourne visible sinon hidden     \n      // Exemple : imaginons que currentPair[0] = 2 et que index = 2 alors on retourne visible\n      // Cette vérification de condition ternaire est faite sur chaque élément du tableau Card\n      // afin de déterminer quelle est la visibilité de la Card par exemple : si index === 2 \n      // On est donc dans l'index 2 du tableau de Card et comme currentPair[0] est égal à 2 aussi alors\n      // pour cet index la valeur sera visible et toutes les autres seront hidden \n\n      console.log(\"GETFEEDBACKFORCARDS ::: On va rendre cette carte VISIBLE car son index dans le tableau est égal à \", index, \" et que la carte qui vient d'être cliquée a été plcée ds currentPair et avait pour index : \", currentPair[0]);\n      console.log(\"GETFEEDBACKFORCARDS ::: ****************** currentPair.length Voici comment sera afficher l'image : \", indexMatched || index === currentPair[0] ? 'visible' : 'hidden'); // on vérifie si l'index est inclu dans la paire actuelle currentPair\n      // Si c'est vérifié on lui ajoute la className justMismatched \n      // et donc cela veut dire qu'on vient de créer une paire \n\n      console.log(\"GETFEEDBACKFORCARDS ::: si le currentPair inclut l'index  \");\n      console.log(\"GETFEEDBACKFORCARDS ::: On vient de créer une paire, Voici comment sera afficher l'image : \", indexMatched ? 'justMatched' : 'justMismatched');\n      console.log(\"GETFEEDBACKFORCARDS ::: 2 click Voici comment sera afficher l'image : \", indexMatched ? 'visible' : 'hidden');\n    } //------------------------------------------------------------\n    // Est appelée dès qu'on clique, sert à gérer le tableau currentPair[]\n    // le tableau currentPair sert à gérer les paires que l'utilisateur est en train d'essayer de créer\n    // ici index est envoyé par le composant Card :\n    // onClick={() => handleClick(index)}\n\n  }, {\n    key: \"handleNewPairClosedBy\",\n    // Détermine si on a trouvé une bonne paire en analysant currentPair et index\n    // On passe ici qu'au deuxieme clique\n    value: function handleNewPairClosedBy(index) {\n      var _this2 = this;\n\n      console.log(\"handleNewPairClosedBy ::: DEBUT\");\n      var _this$state2 = this.state,\n          cards = _this$state2.cards,\n          currentPair = _this$state2.currentPair,\n          guesses = _this$state2.guesses,\n          matchedCardIndices = _this$state2.matchedCardIndices,\n          matchedCardSymbols = _this$state2.matchedCardSymbols; // on va créer un tableau qui contient la premiere carte qu'on a mit ds currentPair lors du premier\n      // clique, et qui va contenir aussi la deuxieme carte qui vient juste d'être cliquée\n\n      console.log(\"handleNewPairClosedBy ::: Détermine si on a trouvé une bonne paire\");\n      console.log(\"handleNewPairClosedBy ::: On compare le 1er click : \".concat(currentPair[0], \" avec le 2eme click : \").concat(index, \" \"));\n      var newPair = [currentPair[0], index];\n      var matched = cards[currentPair[0]] === cards[index];\n      var newGuesses = guesses + 1;\n      this.setState({\n        currentPair: newPair\n      });\n\n      if (matched) {\n        var pairSymbols = [cards[currentPair[0]], cards[index]];\n        return this.setState({\n          matchedCardIndices: [].concat(_toConsumableArray(matchedCardIndices), newPair),\n          currentPair: [],\n          guesses: newGuesses,\n          matchedCardSymbols: [].concat(_toConsumableArray(matchedCardSymbols), pairSymbols)\n        });\n      }\n\n      return setTimeout(function () {\n        _this2.setState({\n          currentPair: []\n        });\n      }, VISUAL_PAUSE_MSECS); // on incrémente guesses de 1 pour signaler que le joueur vient d'avoir une chance de jouer\n      // matched est un booleen, il regarde si l'égalité entre l'icone choisie au 1er click et \n      // l'icone choisie au 2eme clique est vérifiée\n      // Il prend le tab cards va à l'index qui se trouve à newPair[0]] et le compare à l'index [newPair[1]\n      // Ici il ne compare pas des chiffres mais bien les SYMBOLES qui se toruvent à ces indexs ds le tab cards\n\n      console.log(\"handleNewPairClosedBy ::: Est-ce qu'elles sont égales ? \", matched); // dans notre state local on selectionne la pté currentPair , on lui donne la nouvelle pair\n      // qui vient d'être fabriquée pour que au 2eme clique, tout le composant soit rechargé\n      // que <Card> soit instancié de nouveau et que du coup la méthode getFeedBackForCards\n      // soit appelée qui donnera la value \"visible\" à notre seconde card  \n\n      console.log(\"handleNewPairClosedBy ::: On appelle setState\"); // si matched est true alors on a une paire valide\n\n      console.log(\"handleNewPairClosedBy ::: Les cartes étaient identiques donc on appelle setState\");\n      console.log(\"handleNewPairClosedBy ::: pour faire persister 2 cards on les place dans matchedCardIndices\"); // étant donné que les 2 cartes sont identiques il s'agit donc d'une paire \n      // puisque c'est une paire qui a été trouvée il faut la persister dans le state local afin que l'on\n      // sache que cette paire doit tj être affichée, pr cela on utilise le spread operator\n      // en lui disant tu prends l'ancien tableau matchedCardIndices et tu lui rajoute la nouvelle pair\n      // qui se trouve dans le tableau newPair\n      // on copie les valeurs et pas le tableau en lui-même\n      // on passe ici ds tous les cas, apres un certain temps on vide le tableau currentPair\n      // puisqu'on passe ici à chaque fois, le tableau currentPair est vidé à chaque fois\n      // donc on peut en conclure qu'après 2 clics le tableau est toujours vidé \n\n      console.log(\"handleNewPairClosedBy ::: on va faire le timeOut, le currentPair est vidé\");\n      console.log(\"handleNewPairClosedBy ::: FIN\");\n    } // Affiche le tableau d'honneur une fois que toutes les paires sont trouvées\n    // et que donc la partie est terminée\n    // voilà comment est appelée cette method : \n    // {this.displayHallOfFame}\n    // donc on dit que cette méthode est appelée par référence car on ne fait que donner le nom de la méthode\n    // sans parenthèses, et donc on est obligés d'utiliser une fonction fléchée pr pouvoir acceder au this\n    // à l'interieur \n\n  }, {\n    key: \"render\",\n    // Est executé à l'init ET à chaque fois que setState est appelé\n    value: function render() {\n      var _this3 = this;\n\n      var _this$state3 = this.state,\n          cards = _this$state3.cards,\n          guesses = _this$state3.guesses,\n          myEntries = _this$state3.myEntries,\n          matchedCardIndices = _this$state3.matchedCardIndices,\n          matchedCardSymbols = _this$state3.matchedCardSymbols;\n      console.log(\"RENDER ::: DEBUT\");\n      console.log(\"RENDER ::: on va construire chaque card en faisant un map() sur le tableau de card ; \", cards);\n      var won = matchedCardIndices.length === 2; // à chaque    fois que map créer un Card on execute la méthode getFeedBackForCard,\n      // et on sait d'ailleurs qu'à chaque fois que la méthode render est appelée les Cards seront toutes recréées\n      // DONC a chaque fois la méthode getFeedbackforcard sera appelée\n\n      return React.createElement(\"div\", {\n        className: \"memory\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 231\n        },\n        __self: this\n      }, React.createElement(GuessCount, {\n        guesses: guesses,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 232\n        },\n        __self: this\n      }), cards.map(function (card, index) {\n        return React.createElement(Card, {\n          card: card,\n          feedback: _this3.getFeedbackForCard(index),\n          index: index,\n          key: index,\n          handleClick: _this3.handleCardClick,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 235\n          },\n          __self: this\n        });\n      }), React.createElement(PairedCards, {\n        pairSymbols: matchedCardSymbols,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 244\n        },\n        __self: this\n      }), console.log(\"RENDER ::: les 36 instances de Cards on été faites. Maintenant, les composants <Card> existent.\"), // Ici on dit : \"si won est true ALORS on fait une condition ternaire\" \n      won && (myEntries ? //Si hallOfFame\n      React.createElement(HallOfFame, {\n        entries: myEntries,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 253\n        },\n        __self: this\n      }) : React.createElement(HighScoreInput, {\n        guesses: guesses,\n        displayHallOfFame: this.displayHallOfFame,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 257\n        },\n        __self: this\n      })), console.log(\"RENDER ::: FIN\"));\n    }\n  }]);\n\n  return App;\n}(Component);\n\nexport default App;","map":{"version":3,"sources":["/home/juliette/Documents/memorylaporte/src/App.js"],"names":["React","Component","shuffle","HighScoreInput","Card","GuessCount","HallOfFame","PairedCards","SIDE","SYMBOLS","VISUAL_PAUSE_MSECS","App","state","cards","generateCards","currentPair","guesses","myEntries","matchedCardIndices","matchedCardSymbols","handleCardClick","index","console","log","length","setState","handleNewPairClosedBy","displayHallOfFame","entries","result","size","candidates","card","pop","push","indexMatched","includes","newPair","matched","newGuesses","pairSymbols","setTimeout","won","map","getFeedbackForCard"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport shuffle from 'lodash.shuffle'\nimport './App.css'\nimport HighScoreInput from \"./HighScoreInput\"\nimport Card from './Card'\nimport GuessCount from './GuessCount'\nimport HallOfFame from './HallOfFame'\nimport PairedCards from './PairedCards';\n\nconst SIDE = 6\nconst SYMBOLS = '😀🎉💖🎩🐶🐱🦄🐬🌍🌛🌞💫🍎🍌🍓🍐🍟🍿'\nconst VISUAL_PAUSE_MSECS = 750\n// Le but de cette application est d'arriver à trouver 15 paires qui se ressemblent\n// Les 15 paires doivent être trouvées par le joueur en cliquant sur les cartes , \n// Une fois qu'il a cliqué 2 fois, si les 2 cartes sont les mêmes, elles restent affichées\n// Si elles sont différentes, elles disparaissent\n// lorsque les 15 paires sont trouvées un composant HallOfFame apparaît\nclass App extends Component {\n  state = {\n    cards: this.generateCards(),\n    currentPair: [],\n    guesses: 0,\n    myEntries: null,\n    matchedCardIndices: [],\n    matchedCardSymbols: [],\n  }\n\n  // Fait un tableau d'icones à partir de symbols\n  // est appelé dès l'init      \n  generateCards() {\n    console.log(\"GENERATECARDS ::: DEBUT\")\n    console.log(\"GENERATECARDS ::: INIT de l'aplication\")\n    console.log(\"GENERATECARDS ::: on construit le tableau de cards\")\n    const result = []\n    const size = SIDE * SIDE\n    const candidates = shuffle(SYMBOLS)\n    while (result.length < size) {\n      const card = candidates.pop()\n      result.push(card, card)\n    }\n    return shuffle(result)\n  }\n\n  // défini si ma carte est visible ou pas,\n  // du coup est appelé à chaque fois qu'on clique\n  // et à chaque fois qu'on clique il y a un render et elle est appelée pour chaque instance de <Card>\n  // voilà comment est appelé ce code :\n  // {this.getFeedbackForCard(index)}\n  // la fonction est appelé avec les parenthèses et un paramètre\n  // donc ici le this est connu\n  getFeedbackForCard(index) {\n    console.log(\"GETFEEDBACKFORCARDS ::: DEBUT\")\n    console.log(\"GETFEEDBACKFORCARDS ::: détermine comment il faut afficher la carte\")\n    console.log(\"GETFEEDBACKFORCARDS ::: voici index : \", index)\n    const { currentPair, matchedCardIndices } = this.state;\n    console.log(\"GETFEEDBACKFORCARDS::: voici la valeur de currentPair : \", currentPair)\n    // indexMatched est un booleen, il regarde si il y a \"index\" dans le tableau matchedCardIndices,\n    // le tableau matchedCardIndices contient les paires qui ont déjà été validées\n    const indexMatched = matchedCardIndices.includes(index)\n    console.log(`GETFEEDBACKFORCARDS ::: voici matchecardindices : ${matchedCardIndices}`)\n    console.log(`GETFEEDBACKFORCARDS ::: voici indexMatched : ${indexMatched}`)\n\n    // ce code est appelé lors du 1er click\n    if (currentPair.length < 2) {\n      // ici , c le premier click, on regarde si indexMatched est à true, si oui ça veut dire que l'index \n      // sur lequel on a clické\n      // fait deja partie d'une paire donc ici on fait un return ce qui fait que l'instruction\n      // après le || n'est pas effectuée et surtout qu'on return, ce qui arrete la méthode,\n\n      //return indexMatched || currentPair[0] === index ? \"visible\" : \"hidden\"\n      /* Cette ligne ^ peut s'écrire comme ça :  */\n      if (indexMatched) {\n        return;\n      } else {\n\n        // d'abord handleclick est appelé, il place dans currentPair l'index qui a été clické      \n        // donc ici est retourné visible pour cet index et sinon hidden\n        return index === currentPair[0] ? 'visible' : 'hidden'\n      }\n    }\n\n    if (currentPair.includes(index)) {\n      return indexMatched ? 'justMatched' : 'justMismatched'\n    }\n\n    return indexMatched ? 'visible' : 'hidden'\n\n    // comprendre cette ligne de code : \n    // soit on retourne indexMatched soit on retourne la réponse de la condition ternaire\n    // Si indexMatched === true alors on retourne true \n    // Si indexMatched === false alors on execute la condition ternaire\n    // la condition ternaire : la condition ternaire dit si index est égal au 1er élément du tableau \n    // currentPair alors on retourne visible sinon hidden     \n    // Exemple : imaginons que currentPair[0] = 2 et que index = 2 alors on retourne visible\n    // Cette vérification de condition ternaire est faite sur chaque élément du tableau Card\n    // afin de déterminer quelle est la visibilité de la Card par exemple : si index === 2 \n    // On est donc dans l'index 2 du tableau de Card et comme currentPair[0] est égal à 2 aussi alors\n    // pour cet index la valeur sera visible et toutes les autres seront hidden \n\n    console.log(\"GETFEEDBACKFORCARDS ::: On va rendre cette carte VISIBLE car son index dans le tableau est égal à \", index, \" et que la carte qui vient d'être cliquée a été plcée ds currentPair et avait pour index : \", currentPair[0])\n\n    console.log(\"GETFEEDBACKFORCARDS ::: ****************** currentPair.length Voici comment sera afficher l'image : \", indexMatched || index === currentPair[0] ? 'visible' : 'hidden')\n    // on vérifie si l'index est inclu dans la paire actuelle currentPair\n\n    // Si c'est vérifié on lui ajoute la className justMismatched \n    // et donc cela veut dire qu'on vient de créer une paire \n    console.log(\"GETFEEDBACKFORCARDS ::: si le currentPair inclut l'index  \")\n    console.log(\"GETFEEDBACKFORCARDS ::: On vient de créer une paire, Voici comment sera afficher l'image : \", indexMatched ? 'justMatched' : 'justMismatched')\n\n    console.log(\"GETFEEDBACKFORCARDS ::: 2 click Voici comment sera afficher l'image : \", indexMatched ? 'visible' : 'hidden')\n  }\n  //------------------------------------------------------------\n\n  // Est appelée dès qu'on clique, sert à gérer le tableau currentPair[]\n  // le tableau currentPair sert à gérer les paires que l'utilisateur est en train d'essayer de créer\n  // ici index est envoyé par le composant Card :\n  // onClick={() => handleClick(index)}\n  handleCardClick = (index) => {\n    console.log(\"HANDLECARDCLICK ::: DEBUT\")\n    console.log(\"HANDLECARDCLICK ::: est appelée à chaque click\")\n    console.log(\"HANDLECARDCLICK ::: on vient de cliquer sur une carte qui se trouve à l'index ; \", index, \" du tableau this.cards \", this.state.cards)\n\n    const { currentPair } = this.state\n\n    if (currentPair.length === 0) {\n      return this.setState({ currentPair: [index] })\n    }\n    if (currentPair.length === 2) {\n      return\n    }\n    return this.handleNewPairClosedBy(index)\n\n    // pour l'instant ce code n'est pas appelle\n\n    // ce code est appellé lors du premier click\n\n    // si toute les cartes sont avec un ? c'est qu'aucune pair n'a commencé à êtrer créée\n    // donc le tableau currentpair qui gère les paires de cartes, est vide\n    // puisque le tableau est vide on met à jour le currentPair ds le state avec\n    // l'index de la carte qui vient d'etre cliquée\n    // et donc maintenant le currentPair du State n'est plus vide et n'est plus égal à 0, donc on ne repassera \n    // plus ici \n    console.log(\" HANDLECARDCLICK ::: l'index sur lequel on a cliqué est placé dans currentPair\")\n    console.log(\" HANDLECARDCLICK ::: on fait un set state pour currentPair\")\n\n    // ce code est appellé au deuxième clique\n    console.log(\"HANDLECARDCLICK ::: 2EME CLICK : on appelle handleNewPairClosedBy\")\n\n    console.log(\"HANDLECARDCLICK ::: FIN\")\n  }\n\n  // Détermine si on a trouvé une bonne paire en analysant currentPair et index\n  // On passe ici qu'au deuxieme clique\n  handleNewPairClosedBy(index) {\n    console.log(\"handleNewPairClosedBy ::: DEBUT\")\n    const { cards, currentPair, guesses, matchedCardIndices, matchedCardSymbols } = this.state\n    // on va créer un tableau qui contient la premiere carte qu'on a mit ds currentPair lors du premier\n    // clique, et qui va contenir aussi la deuxieme carte qui vient juste d'être cliquée\n    console.log(\"handleNewPairClosedBy ::: Détermine si on a trouvé une bonne paire\")\n    console.log(`handleNewPairClosedBy ::: On compare le 1er click : ${currentPair[0]} avec le 2eme click : ${index} `)\n\n    const newPair = [currentPair[0], index];\n    const matched = cards[currentPair[0]] === cards[index];\n\n    const newGuesses = guesses + 1;\n    this.setState({ currentPair: newPair })\n    if (matched) {\n      const pairSymbols = [cards[currentPair[0]], cards[index]];\n      return this.setState({ matchedCardIndices: [...matchedCardIndices, ...newPair], currentPair: [], guesses: newGuesses, matchedCardSymbols: [...matchedCardSymbols, ...pairSymbols] })\n    }\n    return setTimeout(() => { this.setState({ currentPair: [] }) }, VISUAL_PAUSE_MSECS);\n    // on incrémente guesses de 1 pour signaler que le joueur vient d'avoir une chance de jouer\n\n    // matched est un booleen, il regarde si l'égalité entre l'icone choisie au 1er click et \n    // l'icone choisie au 2eme clique est vérifiée\n    // Il prend le tab cards va à l'index qui se trouve à newPair[0]] et le compare à l'index [newPair[1]\n    // Ici il ne compare pas des chiffres mais bien les SYMBOLES qui se toruvent à ces indexs ds le tab cards\n\n    console.log(\"handleNewPairClosedBy ::: Est-ce qu'elles sont égales ? \", matched)\n    // dans notre state local on selectionne la pté currentPair , on lui donne la nouvelle pair\n    // qui vient d'être fabriquée pour que au 2eme clique, tout le composant soit rechargé\n    // que <Card> soit instancié de nouveau et que du coup la méthode getFeedBackForCards\n    // soit appelée qui donnera la value \"visible\" à notre seconde card  \n    console.log(\"handleNewPairClosedBy ::: On appelle setState\")\n\n    // si matched est true alors on a une paire valide\n\n    console.log(\"handleNewPairClosedBy ::: Les cartes étaient identiques donc on appelle setState\")\n    console.log(\"handleNewPairClosedBy ::: pour faire persister 2 cards on les place dans matchedCardIndices\")\n    // étant donné que les 2 cartes sont identiques il s'agit donc d'une paire \n    // puisque c'est une paire qui a été trouvée il faut la persister dans le state local afin que l'on\n    // sache que cette paire doit tj être affichée, pr cela on utilise le spread operator\n    // en lui disant tu prends l'ancien tableau matchedCardIndices et tu lui rajoute la nouvelle pair\n    // qui se trouve dans le tableau newPair\n    // on copie les valeurs et pas le tableau en lui-même\n\n    // on passe ici ds tous les cas, apres un certain temps on vide le tableau currentPair\n    // puisqu'on passe ici à chaque fois, le tableau currentPair est vidé à chaque fois\n    // donc on peut en conclure qu'après 2 clics le tableau est toujours vidé \n    console.log(\"handleNewPairClosedBy ::: on va faire le timeOut, le currentPair est vidé\")\n\n    console.log(\"handleNewPairClosedBy ::: FIN\")\n  }\n\n\n  // Affiche le tableau d'honneur une fois que toutes les paires sont trouvées\n  // et que donc la partie est terminée\n  // voilà comment est appelée cette method : \n  // {this.displayHallOfFame}\n  // donc on dit que cette méthode est appelée par référence car on ne fait que donner le nom de la méthode\n  // sans parenthèses, et donc on est obligés d'utiliser une fonction fléchée pr pouvoir acceder au this\n  // à l'interieur \n  displayHallOfFame = (entries) => {\n    this.setState({ myEntries: entries })\n    // On peut aussi l'écrire comme ça : \n    // this.setState({ hallOfFame })\n    // ené écrivant (hallOfFame) à la place de (entries) ds les params ^\n  }\n  \n\n  // Est executé à l'init ET à chaque fois que setState est appelé\n  render() {\n    const { cards, guesses,  myEntries, matchedCardIndices, matchedCardSymbols } = this.state\n    console.log(\"RENDER ::: DEBUT\")\n    console.log(\"RENDER ::: on va construire chaque card en faisant un map() sur le tableau de card ; \", cards)\n    const won = matchedCardIndices.length === 2\n    // à chaque    fois que map créer un Card on execute la méthode getFeedBackForCard,\n    // et on sait d'ailleurs qu'à chaque fois que la méthode render est appelée les Cards seront toutes recréées\n    // DONC a chaque fois la méthode getFeedbackforcard sera appelée\n    return (\n      <div className=\"memory\">\n        <GuessCount guesses={guesses} />\n\n        {cards.map((card, index) => (\n          <Card\n            card={card}\n            feedback={this.getFeedbackForCard(index)}\n            index={index}\n            key={index}\n            handleClick={this.handleCardClick}\n          />\n        ))}\n\n        <PairedCards pairSymbols={matchedCardSymbols} />\n\n        {console.log(\"RENDER ::: les 36 instances de Cards on été faites. Maintenant, les composants <Card> existent.\")}\n\n        { // Ici on dit : \"si won est true ALORS on fait une condition ternaire\" \n          won &&\n          ( myEntries ?\n            (\n              //Si hallOfFame\n              <HallOfFame entries={myEntries} />\n            )\n            :\n            (\n              <HighScoreInput guesses={guesses} displayHallOfFame={this.displayHallOfFame} />\n            )\n          )\n        }\n        {console.log(\"RENDER ::: FIN\")}\n      </div>\n    )\n  }\n}\n\nexport default App\n"]},"metadata":{},"sourceType":"module"}